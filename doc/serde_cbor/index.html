<!DOCTYPE html><html lang="en"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1.0"><meta name="generator" content="rustdoc"><meta name="description" content="API documentation for the Rust `serde_cbor` crate."><meta name="keywords" content="rust, rustlang, rust-lang, serde_cbor"><title>serde_cbor - Rust</title><link rel="stylesheet" type="text/css" href="../normalize.css"><link rel="stylesheet" type="text/css" href="../rustdoc.css" id="mainThemeStyle"><link rel="stylesheet" type="text/css" href="../light.css"  id="themeStyle"><link rel="stylesheet" type="text/css" href="../dark.css" disabled ><link rel="stylesheet" type="text/css" href="../ayu.css" disabled ><script src="../storage.js"></script><noscript><link rel="stylesheet" href="../noscript.css"></noscript><link rel="icon" type="image/svg+xml" href="../favicon.svg">
<link rel="alternate icon" type="image/png" href="../favicon-16x16.png">
<link rel="alternate icon" type="image/png" href="../favicon-32x32.png"><style type="text/css">#crate-search{background-image:url("../down-arrow.svg");}</style></head><body class="rustdoc mod"><!--[if lte IE 8]><div class="warning">This old browser is unsupported and will most likely display funky things.</div><![endif]--><nav class="sidebar"><div class="sidebar-menu">&#9776;</div><a href='../serde_cbor/index.html'><div class='logo-container rust-logo'><img src='../rust-logo.png' alt='logo'></div></a><p class='location'>Crate serde_cbor</p><div class='block version'><p>Version 0.11.1</p></div><div class="sidebar-elems"><a id='all-types' href='all.html'><p>See all serde_cbor's items</p></a><div class="block items"><ul><li><a href="#modules">Modules</a></li><li><a href="#structs">Structs</a></li><li><a href="#enums">Enums</a></li><li><a href="#functions">Functions</a></li><li><a href="#types">Type Definitions</a></li></ul></div><p class='location'></p><script>window.sidebarCurrent = {name: 'serde_cbor', ty: 'mod', relpath: '../'};</script></div></nav><div class="theme-picker"><button id="theme-picker" aria-label="Pick another theme!"><img src="../brush.svg" width="18" alt="Pick another theme!"></button><div id="theme-choices"></div></div><script src="../theme.js"></script><nav class="sub"><form class="search-form"><div class="search-container"><div><select id="crate-search"><option value="All crates">All crates</option></select><input class="search-input" name="search" disabled autocomplete="off" spellcheck="false" placeholder="Click or press ‘S’ to search, ‘?’ for more options…" type="search"></div><span class="help-button">?</span>
                <a id="settings-menu" href="../settings.html"><img src="../wheel.svg" width="18" alt="Change settings"></a></div></form></nav><section id="main" class="content"><h1 class='fqn'><span class='out-of-band'><span id='render-detail'><a id="toggle-all-docs" href="javascript:void(0)" title="collapse all docs">[<span class='inner'>&#x2212;</span>]</a></span><a class='srclink' href='../src/serde_cbor/lib.rs.html#1-311' title='goto source code'>[src]</a></span><span class='in-band'>Crate <a class="mod" href=''>serde_cbor</a></span></h1><div class='docblock'><p>CBOR and serialization.</p>
<h1 id="usage" class="section-header"><a href="#usage">Usage</a></h1>
<p>Serde CBOR supports Rust 1.40 and up. Add this to your <code>Cargo.toml</code>:</p>
<pre><code class="language-toml">[dependencies]
serde_cbor = &quot;0.10&quot;
</code></pre>
<p>Storing and loading Rust types is easy and requires only
minimal modifications to the program code.</p>

<div class="example-wrap"><pre class="rust rust-example-rendered">
<span class="kw">use</span> <span class="ident">serde_derive</span>::{<span class="ident">Deserialize</span>, <span class="ident">Serialize</span>};
<span class="kw">use</span> <span class="ident">std</span>::<span class="ident">error</span>::<span class="ident">Error</span>;
<span class="kw">use</span> <span class="ident">std</span>::<span class="ident">fs</span>::<span class="ident">File</span>;

<span class="comment">// Types annotated with `Serialize` can be stored as CBOR.</span>
<span class="comment">// To be able to load them again add `Deserialize`.</span>
<span class="attribute">#[<span class="ident">derive</span>(<span class="ident">Debug</span>, <span class="ident">Serialize</span>, <span class="ident">Deserialize</span>)]</span>
<span class="kw">struct</span> <span class="ident">Mascot</span> {
    <span class="ident">name</span>: <span class="ident">String</span>,
    <span class="ident">species</span>: <span class="ident">String</span>,
    <span class="ident">year_of_birth</span>: <span class="ident">u32</span>,
}

<span class="kw">fn</span> <span class="ident">main</span>() <span class="op">-</span><span class="op">&gt;</span> <span class="prelude-ty">Result</span><span class="op">&lt;</span>(), <span class="ident">Box</span><span class="op">&lt;</span><span class="ident">dyn</span> <span class="ident">Error</span><span class="op">&gt;</span><span class="op">&gt;</span> {
    <span class="kw">let</span> <span class="ident">ferris</span> <span class="op">=</span> <span class="ident">Mascot</span> {
        <span class="ident">name</span>: <span class="string">&quot;Ferris&quot;</span>.<span class="ident">to_owned</span>(),
        <span class="ident">species</span>: <span class="string">&quot;crab&quot;</span>.<span class="ident">to_owned</span>(),
        <span class="ident">year_of_birth</span>: <span class="number">2015</span>,
    };

    <span class="kw">let</span> <span class="ident">ferris_file</span> <span class="op">=</span> <span class="ident">File</span>::<span class="ident">create</span>(<span class="string">&quot;examples/ferris.cbor&quot;</span>)<span class="question-mark">?</span>;
    <span class="comment">// Write Ferris to the given file.</span>
    <span class="comment">// Instead of a file you can use any type that implements `io::Write`</span>
    <span class="comment">// like a HTTP body, database connection etc.</span>
    <span class="ident">serde_cbor</span>::<span class="ident">to_writer</span>(<span class="ident">ferris_file</span>, <span class="kw-2">&amp;</span><span class="ident">ferris</span>)<span class="question-mark">?</span>;

    <span class="kw">let</span> <span class="ident">tux_file</span> <span class="op">=</span> <span class="ident">File</span>::<span class="ident">open</span>(<span class="string">&quot;examples/tux.cbor&quot;</span>)<span class="question-mark">?</span>;
    <span class="comment">// Load Tux from a file.</span>
    <span class="comment">// Serde CBOR performs roundtrip serialization meaning that</span>
    <span class="comment">// the data will not change in any way.</span>
    <span class="kw">let</span> <span class="ident">tux</span>: <span class="ident">Mascot</span> <span class="op">=</span> <span class="ident">serde_cbor</span>::<span class="ident">from_reader</span>(<span class="ident">tux_file</span>)<span class="question-mark">?</span>;

    <span class="macro">println</span><span class="macro">!</span>(<span class="string">&quot;{:?}&quot;</span>, <span class="ident">tux</span>);
    <span class="comment">// prints: Mascot { name: &quot;Tux&quot;, species: &quot;penguin&quot;, year_of_birth: 1996 }</span>

    <span class="prelude-val">Ok</span>(())
}</pre></div>
<p>There are a lot of options available to customize the format.
To operate on untyped CBOR values have a look at the <code>Value</code> type.</p>
<h1 id="type-based-serialization-and-deserialization" class="section-header"><a href="#type-based-serialization-and-deserialization">Type-based Serialization and Deserialization</a></h1>
<p>Serde provides a mechanism for low boilerplate serialization &amp; deserialization of values to and
from CBOR via the serialization API. To be able to serialize a piece of data, it must implement
the <code>serde::Serialize</code> trait. To be able to deserialize a piece of data, it must implement the
<code>serde::Deserialize</code> trait. Serde provides an annotation to automatically generate the
code for these traits: <code>#[derive(Serialize, Deserialize)]</code>.</p>
<p>The CBOR API also provides an enum <code>serde_cbor::Value</code>.</p>
<h1 id="packed-encoding" class="section-header"><a href="#packed-encoding">Packed Encoding</a></h1>
<p>When serializing structs or enums in CBOR the keys or enum variant names will be serialized
as string keys to a map. Especially in embedded environments this can increase the file
size too much. In packed encoding the keys and variants will be serialized as variable sized
integers. The first 24 entries in any struct consume only a single byte!
To serialize a document in this format use <code>Serializer::new(writer).packed_format()</code> or
the shorthand <code>ser::to_vec_packed</code>. The deserialization works without any changes.</p>
<h1 id="self-describing-documents" class="section-header"><a href="#self-describing-documents">Self describing documents</a></h1>
<p>In some contexts different formats are used but there is no way to declare the format used
out of band. For this reason CBOR has a magic number that may be added before any document.
Self describing documents are created with <code>serializer.self_describe()</code>.</p>
<h1 id="examples" class="section-header"><a href="#examples">Examples</a></h1>
<p>Read a CBOR value that is known to be a map of string keys to string values and print it.</p>

<div class="example-wrap"><pre class="rust rust-example-rendered">
<span class="kw">use</span> <span class="ident">std</span>::<span class="ident">collections</span>::<span class="ident">BTreeMap</span>;
<span class="kw">use</span> <span class="ident">serde_cbor</span>::<span class="ident">from_slice</span>;

<span class="kw">let</span> <span class="ident">slice</span> <span class="op">=</span> <span class="string">b&quot;\xa5aaaAabaBacaCadaDaeaE&quot;</span>;
<span class="kw">let</span> <span class="ident">value</span>: <span class="ident">BTreeMap</span><span class="op">&lt;</span><span class="ident">String</span>, <span class="ident">String</span><span class="op">&gt;</span> <span class="op">=</span> <span class="ident">from_slice</span>(<span class="ident">slice</span>).<span class="ident">unwrap</span>();
<span class="macro">println</span><span class="macro">!</span>(<span class="string">&quot;{:?}&quot;</span>, <span class="ident">value</span>); <span class="comment">// {&quot;e&quot;: &quot;E&quot;, &quot;d&quot;: &quot;D&quot;, &quot;a&quot;: &quot;A&quot;, &quot;c&quot;: &quot;C&quot;, &quot;b&quot;: &quot;B&quot;}</span></pre></div>
<p>Read a general CBOR value with an unknown content.</p>

<div class="example-wrap"><pre class="rust rust-example-rendered">
<span class="kw">use</span> <span class="ident">serde_cbor</span>::<span class="ident">from_slice</span>;
<span class="kw">use</span> <span class="ident">serde_cbor</span>::<span class="ident">value</span>::<span class="ident">Value</span>;

<span class="kw">let</span> <span class="ident">slice</span> <span class="op">=</span> <span class="string">b&quot;\x82\x01\xa1aaab&quot;</span>;
<span class="kw">let</span> <span class="ident">value</span>: <span class="ident">Value</span> <span class="op">=</span> <span class="ident">from_slice</span>(<span class="ident">slice</span>).<span class="ident">unwrap</span>();
<span class="macro">println</span><span class="macro">!</span>(<span class="string">&quot;{:?}&quot;</span>, <span class="ident">value</span>); <span class="comment">// Array([U64(1), Object({String(&quot;a&quot;): String(&quot;b&quot;)})])</span></pre></div>
<p>Serialize an object.</p>

<div class="example-wrap"><pre class="rust rust-example-rendered">
<span class="kw">use</span> <span class="ident">std</span>::<span class="ident">collections</span>::<span class="ident">BTreeMap</span>;
<span class="kw">use</span> <span class="ident">serde_cbor</span>::<span class="ident">to_vec</span>;

<span class="kw">let</span> <span class="kw-2">mut</span> <span class="ident">programming_languages</span> <span class="op">=</span> <span class="ident">BTreeMap</span>::<span class="ident">new</span>();
<span class="ident">programming_languages</span>.<span class="ident">insert</span>(<span class="string">&quot;rust&quot;</span>, <span class="macro">vec</span><span class="macro">!</span>[<span class="string">&quot;safe&quot;</span>, <span class="string">&quot;concurrent&quot;</span>, <span class="string">&quot;fast&quot;</span>]);
<span class="ident">programming_languages</span>.<span class="ident">insert</span>(<span class="string">&quot;python&quot;</span>, <span class="macro">vec</span><span class="macro">!</span>[<span class="string">&quot;powerful&quot;</span>, <span class="string">&quot;friendly&quot;</span>, <span class="string">&quot;open&quot;</span>]);
<span class="ident">programming_languages</span>.<span class="ident">insert</span>(<span class="string">&quot;js&quot;</span>, <span class="macro">vec</span><span class="macro">!</span>[<span class="string">&quot;lightweight&quot;</span>, <span class="string">&quot;interpreted&quot;</span>, <span class="string">&quot;object-oriented&quot;</span>]);
<span class="kw">let</span> <span class="ident">encoded</span> <span class="op">=</span> <span class="ident">to_vec</span>(<span class="kw-2">&amp;</span><span class="ident">programming_languages</span>);
<span class="macro">assert_eq</span><span class="macro">!</span>(<span class="ident">encoded</span>.<span class="ident">unwrap</span>().<span class="ident">len</span>(), <span class="number">103</span>);</pre></div>
<p>Deserializing data in the middle of a slice</p>

<div class="example-wrap"><pre class="rust rust-example-rendered">
<span class="kw">use</span> <span class="ident">serde_cbor</span>::<span class="ident">Deserializer</span>;

<span class="kw">let</span> <span class="ident">data</span>: <span class="ident">Vec</span><span class="op">&lt;</span><span class="ident">u8</span><span class="op">&gt;</span> <span class="op">=</span> <span class="macro">vec</span><span class="macro">!</span>[
    <span class="number">0x66</span>, <span class="number">0x66</span>, <span class="number">0x6f</span>, <span class="number">0x6f</span>, <span class="number">0x62</span>, <span class="number">0x61</span>, <span class="number">0x72</span>, <span class="number">0x66</span>, <span class="number">0x66</span>, <span class="number">0x6f</span>, <span class="number">0x6f</span>, <span class="number">0x62</span>,
    <span class="number">0x61</span>, <span class="number">0x72</span>,
];
<span class="kw">let</span> <span class="kw-2">mut</span> <span class="ident">deserializer</span> <span class="op">=</span> <span class="ident">Deserializer</span>::<span class="ident">from_slice</span>(<span class="kw-2">&amp;</span><span class="ident">data</span>);
<span class="kw">let</span> <span class="ident">value</span>: <span class="kw-2">&amp;</span><span class="ident">str</span> <span class="op">=</span> <span class="ident">serde</span>::<span class="ident">de</span>::<span class="ident">Deserialize</span>::<span class="ident">deserialize</span>(<span class="kw-2">&amp;</span><span class="kw-2">mut</span> <span class="ident">deserializer</span>)
    .<span class="ident">unwrap</span>();
<span class="kw">let</span> <span class="ident">rest</span> <span class="op">=</span> <span class="kw-2">&amp;</span><span class="ident">data</span>[<span class="ident">deserializer</span>.<span class="ident">byte_offset</span>()..];
<span class="macro">assert_eq</span><span class="macro">!</span>(<span class="ident">value</span>, <span class="string">&quot;foobar&quot;</span>);
<span class="macro">assert_eq</span><span class="macro">!</span>(<span class="ident">rest</span>, <span class="kw-2">&amp;</span>[<span class="number">0x66</span>, <span class="number">0x66</span>, <span class="number">0x6f</span>, <span class="number">0x6f</span>, <span class="number">0x62</span>, <span class="number">0x61</span>, <span class="number">0x72</span>]);</pre></div>
<h1 id="no-std-support" class="section-header"><a href="#no-std-support"><code>no-std</code> support</a></h1>
<p>Serde CBOR supports building in a <code>no_std</code> context, use the following lines
in your <code>Cargo.toml</code> dependencies:</p>
<pre><code class="language-toml">[dependencies]
serde = { version = &quot;1.0&quot;, default-features = false }
serde_cbor = { version = &quot;0.10&quot;, default-features = false }
</code></pre>
<p>Without the <code>std</code> feature the functions <a href="../serde_cbor/de/fn.from_reader.html" title="from_reader">from_reader</a>, <a href="../serde_cbor/de/fn.from_slice.html" title="from_slice">from_slice</a>, <a href="../serde_cbor/ser/fn.to_vec.html" title="to_vec">to_vec</a>, and <a href="../serde_cbor/ser/fn.to_writer.html" title="to_writer">to_writer</a>
are not exported. To export <a href="../serde_cbor/de/fn.from_slice.html" title="from_slice">from_slice</a> and <a href="../serde_cbor/ser/fn.to_vec.html" title="to_vec">to_vec</a> enable the <code>alloc</code> feature. The <code>alloc</code>
feature uses the <a href="https://doc.rust-lang.org/alloc/"><code>alloc</code> library</a> and requires at least version 1.36.0 of Rust.</p>
<p><em>Note</em>: to use derive macros in serde you will need to declare <code>serde</code>
dependency like so:</p>
<pre><code class="language-toml">serde = { version = &quot;1.0&quot;, default-features = false, features = [&quot;derive&quot;] }
</code></pre>
<p>Serialize an object with <code>no_std</code> and without <code>alloc</code>.</p>

<div class="example-wrap"><pre class="rust rust-example-rendered">
<span class="kw">use</span> <span class="ident">serde</span>::<span class="ident">Serialize</span>;
<span class="kw">use</span> <span class="ident">serde_cbor</span>::<span class="ident">Serializer</span>;
<span class="kw">use</span> <span class="ident">serde_cbor</span>::<span class="ident">ser</span>::<span class="ident">SliceWrite</span>;

<span class="attribute">#[<span class="ident">derive</span>(<span class="ident">Serialize</span>)]</span>
<span class="kw">struct</span> <span class="ident">User</span> {
    <span class="ident">user_id</span>: <span class="ident">u32</span>,
    <span class="ident">password_hash</span>: [<span class="ident">u8</span>; <span class="number">4</span>],
}

<span class="kw">let</span> <span class="kw-2">mut</span> <span class="ident">buf</span> <span class="op">=</span> [<span class="number">0u8</span>; <span class="number">100</span>];
<span class="kw">let</span> <span class="ident">writer</span> <span class="op">=</span> <span class="ident">SliceWrite</span>::<span class="ident">new</span>(<span class="kw-2">&amp;</span><span class="kw-2">mut</span> <span class="ident">buf</span>[..]);
<span class="kw">let</span> <span class="kw-2">mut</span> <span class="ident">ser</span> <span class="op">=</span> <span class="ident">Serializer</span>::<span class="ident">new</span>(<span class="ident">writer</span>);
<span class="kw">let</span> <span class="ident">user</span> <span class="op">=</span> <span class="ident">User</span> {
    <span class="ident">user_id</span>: <span class="number">42</span>,
    <span class="ident">password_hash</span>: [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>],
};
<span class="ident">user</span>.<span class="ident">serialize</span>(<span class="kw-2">&amp;</span><span class="kw-2">mut</span> <span class="ident">ser</span>)<span class="question-mark">?</span>;
<span class="kw">let</span> <span class="ident">writer</span> <span class="op">=</span> <span class="ident">ser</span>.<span class="ident">into_inner</span>();
<span class="kw">let</span> <span class="ident">size</span> <span class="op">=</span> <span class="ident">writer</span>.<span class="ident">bytes_written</span>();
<span class="kw">let</span> <span class="ident">expected</span> <span class="op">=</span> [
    <span class="number">0xa2</span>, <span class="number">0x67</span>, <span class="number">0x75</span>, <span class="number">0x73</span>, <span class="number">0x65</span>, <span class="number">0x72</span>, <span class="number">0x5f</span>, <span class="number">0x69</span>, <span class="number">0x64</span>, <span class="number">0x18</span>, <span class="number">0x2a</span>, <span class="number">0x6d</span>,
    <span class="number">0x70</span>, <span class="number">0x61</span>, <span class="number">0x73</span>, <span class="number">0x73</span>, <span class="number">0x77</span>, <span class="number">0x6f</span>, <span class="number">0x72</span>, <span class="number">0x64</span>, <span class="number">0x5f</span>, <span class="number">0x68</span>, <span class="number">0x61</span>, <span class="number">0x73</span>,
    <span class="number">0x68</span>, <span class="number">0x84</span>, <span class="number">0x1</span>, <span class="number">0x2</span>, <span class="number">0x3</span>, <span class="number">0x4</span>
];
<span class="macro">assert_eq</span><span class="macro">!</span>(<span class="kw-2">&amp;</span><span class="ident">buf</span>[..<span class="ident">size</span>], <span class="ident">expected</span>);</pre></div>
<p>Deserialize an object.</p>

<div class="example-wrap"><pre class="rust rust-example-rendered">
<span class="attribute">#[<span class="ident">derive</span>(<span class="ident">Debug</span>, <span class="ident">PartialEq</span>, <span class="ident">Deserialize</span>)]</span>
<span class="kw">struct</span> <span class="ident">User</span> {
    <span class="ident">user_id</span>: <span class="ident">u32</span>,
    <span class="ident">password_hash</span>: [<span class="ident">u8</span>; <span class="number">4</span>],
}

<span class="kw">let</span> <span class="ident">value</span> <span class="op">=</span> [
    <span class="number">0xa2</span>, <span class="number">0x67</span>, <span class="number">0x75</span>, <span class="number">0x73</span>, <span class="number">0x65</span>, <span class="number">0x72</span>, <span class="number">0x5f</span>, <span class="number">0x69</span>, <span class="number">0x64</span>, <span class="number">0x18</span>, <span class="number">0x2a</span>, <span class="number">0x6d</span>,
    <span class="number">0x70</span>, <span class="number">0x61</span>, <span class="number">0x73</span>, <span class="number">0x73</span>, <span class="number">0x77</span>, <span class="number">0x6f</span>, <span class="number">0x72</span>, <span class="number">0x64</span>, <span class="number">0x5f</span>, <span class="number">0x68</span>, <span class="number">0x61</span>, <span class="number">0x73</span>,
    <span class="number">0x68</span>, <span class="number">0x84</span>, <span class="number">0x1</span>, <span class="number">0x2</span>, <span class="number">0x3</span>, <span class="number">0x4</span>
];

<span class="comment">// from_slice_with_scratch will not alter input data, use it whenever you</span>
<span class="comment">// borrow from somewhere else.</span>
<span class="comment">// You will have to size your scratch according to the input data you</span>
<span class="comment">// expect.</span>
<span class="kw">use</span> <span class="ident">serde_cbor</span>::<span class="ident">de</span>::<span class="ident">from_slice_with_scratch</span>;
<span class="kw">let</span> <span class="kw-2">mut</span> <span class="ident">scratch</span> <span class="op">=</span> [<span class="number">0u8</span>; <span class="number">32</span>];
<span class="kw">let</span> <span class="ident">user</span>: <span class="ident">User</span> <span class="op">=</span> <span class="ident">from_slice_with_scratch</span>(<span class="kw-2">&amp;</span><span class="ident">value</span>[..], <span class="kw-2">&amp;</span><span class="kw-2">mut</span> <span class="ident">scratch</span>)<span class="question-mark">?</span>;
<span class="macro">assert_eq</span><span class="macro">!</span>(<span class="ident">user</span>, <span class="ident">User</span> {
    <span class="ident">user_id</span>: <span class="number">42</span>,
    <span class="ident">password_hash</span>: [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>],
});

<span class="kw">let</span> <span class="kw-2">mut</span> <span class="ident">value</span> <span class="op">=</span> [
    <span class="number">0xa2</span>, <span class="number">0x67</span>, <span class="number">0x75</span>, <span class="number">0x73</span>, <span class="number">0x65</span>, <span class="number">0x72</span>, <span class="number">0x5f</span>, <span class="number">0x69</span>, <span class="number">0x64</span>, <span class="number">0x18</span>, <span class="number">0x2a</span>, <span class="number">0x6d</span>,
    <span class="number">0x70</span>, <span class="number">0x61</span>, <span class="number">0x73</span>, <span class="number">0x73</span>, <span class="number">0x77</span>, <span class="number">0x6f</span>, <span class="number">0x72</span>, <span class="number">0x64</span>, <span class="number">0x5f</span>, <span class="number">0x68</span>, <span class="number">0x61</span>, <span class="number">0x73</span>,
    <span class="number">0x68</span>, <span class="number">0x84</span>, <span class="number">0x1</span>, <span class="number">0x2</span>, <span class="number">0x3</span>, <span class="number">0x4</span>
];

<span class="comment">// from_mut_slice will move data around the input slice, you may only use it</span>
<span class="comment">// on data you may own or can modify.</span>
<span class="kw">use</span> <span class="ident">serde_cbor</span>::<span class="ident">de</span>::<span class="ident">from_mut_slice</span>;
<span class="kw">let</span> <span class="ident">user</span>: <span class="ident">User</span> <span class="op">=</span> <span class="ident">from_mut_slice</span>(<span class="kw-2">&amp;</span><span class="kw-2">mut</span> <span class="ident">value</span>[..])<span class="question-mark">?</span>;
<span class="macro">assert_eq</span><span class="macro">!</span>(<span class="ident">user</span>, <span class="ident">User</span> {
    <span class="ident">user_id</span>: <span class="number">42</span>,
    <span class="ident">password_hash</span>: [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>],
});</pre></div>
<h1 id="limitations" class="section-header"><a href="#limitations">Limitations</a></h1>
<p>While Serde CBOR strives to support all features of Serde and CBOR
there are a few limitations.</p>
<ul>
<li><a href="https://tools.ietf.org/html/rfc7049#section-2.4.4">Tags</a> are ignored during deserialization and can't be emitted during
serialization. This is because Serde has no concept of tagged
values. See: <a href="https://github.com/pyfisch/cbor/issues/3">#3</a></li>
<li>Unknown <a href="https://tools.ietf.org/html/rfc7049#section-3.5">simple values</a> cause an <code>UnassignedCode</code> error.
The simple values <em>False</em> and <em>True</em> are recognized and parsed as bool.
<em>Null</em> and <em>Undefined</em> are both deserialized as <em>unit</em>.
The <em>unit</em> type is serialized as <em>Null</em>. See: <a href="https://github.com/pyfisch/cbor/issues/86">#86</a></li>
<li><a href="https://doc.rust-lang.org/std/primitive.u128.html">128-bit integers</a> can't be directly encoded in CBOR. If you need them
store them as a byte string. See: <a href="https://github.com/pyfisch/cbor/issues/77">#77</a></li>
</ul>
</div><h2 id='modules' class='section-header'><a href="#modules">Modules</a></h2>
<table><tr class='module-item'><td><a class="mod" href="de/index.html" title='serde_cbor::de mod'>de</a></td><td class='docblock-short'><p>Deserialization.</p>
</td></tr><tr class='module-item'><td><a class="mod" href="error/index.html" title='serde_cbor::error mod'>error</a></td><td class='docblock-short'><p>When serializing or deserializing CBOR goes wrong.</p>
</td></tr><tr class='module-item'><td><a class="mod" href="ser/index.html" title='serde_cbor::ser mod'>ser</a></td><td class='docblock-short'><p>Serialize a Rust data structure to CBOR data.</p>
</td></tr><tr class='module-item'><td><a class="mod" href="tags/index.html" title='serde_cbor::tags mod'>tags</a></td><td class='docblock-short'><p>Support for cbor tags</p>
</td></tr><tr class='module-item'><td><a class="mod" href="value/index.html" title='serde_cbor::value mod'>value</a></td><td class='docblock-short'><p>CBOR values, keys and serialization routines.</p>
</td></tr></table><h2 id='structs' class='section-header'><a href="#structs">Structs</a></h2>
<table><tr class='module-item'><td><a class="struct" href="struct.Deserializer.html" title='serde_cbor::Deserializer struct'>Deserializer</a></td><td class='docblock-short'><p>A Serde <code>Deserialize</code>r of CBOR data.</p>
</td></tr><tr class='module-item'><td><a class="struct" href="struct.Error.html" title='serde_cbor::Error struct'>Error</a></td><td class='docblock-short'><p>This type represents all possible errors that can occur when serializing or deserializing CBOR
data.</p>
</td></tr><tr class='module-item'><td><a class="struct" href="struct.Serializer.html" title='serde_cbor::Serializer struct'>Serializer</a></td><td class='docblock-short'><p>A structure for serializing Rust values to CBOR.</p>
</td></tr><tr class='module-item'><td><a class="struct" href="struct.StreamDeserializer.html" title='serde_cbor::StreamDeserializer struct'>StreamDeserializer</a></td><td class='docblock-short'><p>Iterator that deserializes a stream into multiple CBOR values.</p>
</td></tr></table><h2 id='enums' class='section-header'><a href="#enums">Enums</a></h2>
<table><tr class='module-item'><td><a class="enum" href="enum.Value.html" title='serde_cbor::Value enum'>Value</a></td><td class='docblock-short'><p>The <code>Value</code> enum, a loosely typed way of representing any valid CBOR value.</p>
</td></tr></table><h2 id='functions' class='section-header'><a href="#functions">Functions</a></h2>
<table><tr class='module-item'><td><a class="fn" href="fn.from_reader.html" title='serde_cbor::from_reader fn'>from_reader</a></td><td class='docblock-short'><p>Decodes a value from CBOR data in a reader.</p>
</td></tr><tr class='module-item'><td><a class="fn" href="fn.from_slice.html" title='serde_cbor::from_slice fn'>from_slice</a></td><td class='docblock-short'><p>Decodes a value from CBOR data in a slice.</p>
</td></tr><tr class='module-item'><td><a class="fn" href="fn.to_vec.html" title='serde_cbor::to_vec fn'>to_vec</a></td><td class='docblock-short'><p>Serializes a value to a vector.</p>
</td></tr><tr class='module-item'><td><a class="fn" href="fn.to_writer.html" title='serde_cbor::to_writer fn'>to_writer</a></td><td class='docblock-short'><p>Serializes a value to a writer.</p>
</td></tr></table><h2 id='types' class='section-header'><a href="#types">Type Definitions</a></h2>
<table><tr class='module-item'><td><a class="type" href="type.Result.html" title='serde_cbor::Result type'>Result</a></td><td class='docblock-short'><p>Alias for a <code>Result</code> with the error type <code>serde_cbor::Error</code>.</p>
</td></tr></table></section><section id="search" class="content hidden"></section><section class="footer"></section><script>window.rootPath = "../";window.currentCrate = "serde_cbor";</script><script src="../main.js"></script><script defer src="../search-index.js"></script></body></html>